# backtester.py
import pandas as pd
import numpy as np
import logging
from typing import Tuple, Dict, Any

logger = logging.getLogger(__name__)

def run_backtest(strategy_instance, initial_capital: float = 10000.0,
                 fee_rate: float = 0.001, slippage_rate: float = 0.001) -> Tuple[Dict[str, Any], pd.DataFrame]:
    """
    Execute a backtest on the trades generated by the strategy.
    Returns performance metrics and a DataFrame of trade results.
    """
    trades = strategy_instance.trades
    if not trades:
        logger.warning("No trades executed by the strategy.")
        return {}, pd.DataFrame()

    results = []
    capital = initial_capital
    cumulative_profit = [capital]

    for trade in trades:
        trade_type = trade.get('trade_type')
        entry_price = trade.get('entry_price')
        exit_price = trade.get('exit_price')

        if trade_type == 'long':
            effective_entry = entry_price * (1 + slippage_rate)
            effective_exit = exit_price * (1 - slippage_rate)
            profit = effective_exit - effective_entry
        elif trade_type == 'short':
            effective_entry = entry_price * (1 - slippage_rate)
            effective_exit = exit_price * (1 + slippage_rate)
            profit = effective_entry - effective_exit
        else:
            continue

        fee = fee_rate * (effective_entry + effective_exit)
        net_profit = profit - fee
        ret_pct = net_profit / effective_entry

        capital += net_profit
        cumulative_profit.append(capital)

        results.append({
            'trade_type': trade_type,
            'entry_time': trade.get('entry_time'),
            'exit_time': trade.get('exit_time'),
            'entry_price': entry_price,
            'exit_price': exit_price,
            'effective_entry': effective_entry,
            'effective_exit': effective_exit,
            'profit': profit,
            'fee': fee,
            'net_profit': net_profit,
            'return_pct': ret_pct,
            'capital': capital,
            'stop_loss': trade.get('stop_loss'),
            'take_profit': trade.get('take_profit'),
        })

    results_df = pd.DataFrame(results)
    total_trades = len(results_df)
    wins = results_df[results_df['net_profit'] > 0].shape[0]
    win_rate = wins / total_trades if total_trades > 0 else 0
    total_net_profit = capital - initial_capital

    cumulative_profit_series = pd.Series(cumulative_profit)
    running_max = cumulative_profit_series.cummax()
    drawdown = (cumulative_profit_series - running_max) / running_max
    max_drawdown = drawdown.min()

    returns = results_df['return_pct']
    sharpe_ratio = returns.mean() / returns.std() * np.sqrt(len(returns)) if returns.std() > 0 else 0

    performance = {
        'total_trades': total_trades,
        'win_rate': win_rate,
        'total_net_profit': total_net_profit,
        'max_drawdown': max_drawdown,
        'sharpe_ratio': sharpe_ratio,
        'final_capital': capital,
    }

    logger.info("Backtesting Performance: %s", performance)
    return performance, results_df

def backtest_strategy(strategy_class, data, strategy_params: dict, initial_capital: float = 10000.0,
                      fee_rate: float = 0.001, slippage_rate: float = 0.001):
    """
    Convenience function to instantiate a strategy, run it, and backtest the results.
    """
    strategy_instance = strategy_class(data, **strategy_params)
    strategy_instance.run()
    performance, trade_df = run_backtest(strategy_instance, initial_capital, fee_rate, slippage_rate)
    return performance, trade_df
